# bot.py — ПОЛНАЯ ВЕРСИЯ 2025
import asyncio
import aiosqlite
import random
import json
from aiogram import Bot, Dispatcher, Router, F
from aiogram.filters import Command
from aiogram.types import (
    Message, InlineKeyboardMarkup, InlineKeyboardButton,
    WebAppInfo
)
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from dotenv import load_dotenv
from urllib.parse import urlencode
import os
import time

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID"))
WEBAPP_URL = os.getenv("WEBAPP_URL")
COMMISSION = float(os.getenv("COMMISSION", "0.15"))
DB_NAME = os.getenv("DB_NAME", "earn_bot.db")
MIN_WITHDRAW = float(os.getenv("MIN_WITHDRAW", "200"))

TOPUP_PHONE = "+79600738559"
TOPUP_NAME = "Раяз Н."
TOPUP_BANK = "Т-Банк"

if not BOT_TOKEN or not ADMIN_ID or not WEBAPP_URL:
    raise ValueError("BOT_TOKEN, ADMIN_ID и WEBAPP_URL обязательны!")

bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

# === FSM ===
class TopupStates(StatesGroup):
    waiting_amount = State()

class WithdrawStates(StatesGroup):
    waiting_wallet = State()
    waiting_amount = State()

class TaskStates(StatesGroup):
    waiting_text = State()
    waiting_link = State()
    waiting_price = State()

# === БД ===
async def init_db():
    async with aiosqlite.connect(DB_NAME) as db:
        await db.executescript("""
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                role TEXT,
                balance REAL DEFAULT 0
            );
            CREATE TABLE IF NOT EXISTS topups (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                amount REAL,
                code TEXT,
                status TEXT DEFAULT 'pending'
            );
            CREATE TABLE IF NOT EXISTS withdrawals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                amount REAL,
                wallet TEXT,
                status TEXT DEFAULT 'pending'
            );
            CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                employer_id INTEGER,
                text TEXT,
                link TEXT,
                price REAL,
                status TEXT DEFAULT 'active',
                type TEXT
            );
        """)
        await db.commit()
    print("База данных готова.")

# === УТИЛИТЫ ===
async def get_role(user_id):
    async with aiosqlite.connect(DB_NAME) as db:
        async with db.execute("SELECT role FROM users WHERE user_id = ?", (user_id,)) as cursor:
            row = await cursor.fetchone()
            return row[0] if row else None

async def set_role(user_id, role):
    async with aiosqlite.connect(DB_NAME) as db:
        await db.execute("INSERT OR REPLACE INTO users (user_id, role) VALUES (?, ?)", (user_id, role))
        await db.commit()

async def add_balance(user_id, amount):
    async with aiosqlite.connect(DB_NAME) as db:
        await db.execute("UPDATE users SET balance = balance + ? WHERE user_id = ?", (amount, user_id))
        await db.commit()

async def get_balance(user_id):
    async with aiosqlite.connect(DB_NAME) as db:
        async with db.execute("SELECT balance FROM users WHERE user_id = ?", (user_id,)) as cursor:
            row = await cursor.fetchone()
            return row[0] if row else 0.0

def generate_code():
    return f"{random.randint(100000, 999999)}"

# === WebApp: ЧИСТЫЙ ЧАТ ===
@router.message(F.web_app_data)
async def webapp_handler(message: Message):
    try:
        data = json.loads(message.web_app_data.data)
        user_id = message.from_user.id

        if data["action"] == "get_balance":
            balance = await get_balance(user_id)
            result = {"balance": balance}
            await bot.send_message(user_id, json.dumps(result), reply_markup=InlineKeyboardMarkup(inline_keyboard=[[]]))

        elif data["action"] == "get_tasks":
            async with aiosqlite.connect(DB_NAME) as db:
                async with db.execute("SELECT id, text, link, price, type FROM tasks WHERE status = 'active'") as cursor:
                    tasks = await cursor.fetchall()
            result = {"tasks": [
                {"id": t[0], "text": t[1], "link": t[2], "price": t[3], "type": t[4]}
                for t in tasks
            ]}
            await bot.send_message(user_id, json.dumps(result), reply_markup=InlineKeyboardMarkup(inline_keyboard=[[]]))

        elif data["action"] == "topup":
            if await get_role(user_id) != "employer":
                await bot.send_message(user_id, "Только для работодателей!")
            else:
                await bot.send_message(user_id, "Введите сумму пополнения (≥ 100 ₽):")
                # FSM будет обрабатывать дальше

        elif data["action"] == "withdraw":
            if await get_role(user_id) != "executor":
                await bot.send_message(user_id, "Только для исполнителей!")
            else:
                bal = await get_balance(user_id)
                if bal < MIN_WITHDRAW:
                    await bot.send_message(user_id, f"Минимум {MIN_WITHDRAW} ₽")
                else:
                    await bot.send_message(user_id, "Кошелёк:")

    except Exception as e:
        print(f"WebApp error: {e}")

# === /start ===
@router.message(Command("start"))
async def start_command(message: Message):
    user_id = message.from_user.id
    role = await get_role(user_id)
    params = {"user_id": user_id, "role": role or "none", "v": int(time.time())}
    webapp_url = f"{WEBAPP_URL}?{urlencode(params)}"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="Открыть ReviewCash", web_app=WebAppInfo(url=webapp_url))
    ]])

    if not role:
        await message.answer("Выбери роль:", reply_markup=keyboard)
    else:
        balance = await get_balance(user_id)
        role_name = "Работодатель" if role == "employer" else "Исполнитель"
        await message.answer(f"Привет, **{role_name}**!\nБаланс: *{balance:.2f} ₽*", reply_markup=keyboard)

# === СОЗДАНИЕ ЗАДАНИЯ ===
@router.message(Command("newtask"))
async def newtask_start(message: Message, state: FSMContext):
    if await get_role(message.from_user.id) != "employer":
        await message.answer("Только для работодателей!")
        return
    await message.answer("Текст задания:")
    await state.set_state(TaskStates.waiting_text)

@router.message(TaskStates.waiting_text)
async def newtask_text(message: Message, state: FSMContext):
    await state.update_data(text=message.text)
    await message.answer("Ссылка:")
    await state.set_state(TaskStates.waiting_link)

@router.message(TaskStates.waiting_link)
async def newtask_link(message: Message, state: FSMContext):
    await state.update_data(link=message.text)
    await message.answer("Цена (с учётом комиссии):")
    await state.set_state(TaskStates.waiting_price)

@router.message(TaskStates.waiting_price)
async def newtask_price(message: Message, state: FSMContext):
    try:
        price = float(message.text)
    except:
        await message.answer("Введите число")
        return
    data = await state.get_data()
    executor_reward = round(price * (1 - COMMISSION), 2)

    async with aiosqlite.connect(DB_NAME) as db:
        await db.execute("INSERT INTO tasks (employer_id, text, link, price, type) VALUES (?, ?, ?, ?, ?)",
                         (message.from_user.id, data['text'], data['link'], price, "custom"))
        await db.commit()

    await message.answer(
        f"Задание создано!\n"
        f"Вы заплатите: {price} ₽\n"
        f"Исполнитель получит: {executor_reward} ₽"
    )
    await state.clear()

# === ПОПОЛНЕНИЕ ===
@router.message(Command("topup"))
async def topup_start(message: Message, state: FSMContext):
    if await get_role(message.from_user.id) != "employer":
        await message.answer("Только для работодателей!")
        return
    await message.answer("Введите сумму пополнения (≥ 100 ₽):")
    await state.set_state(TopupStates.waiting_amount)

@router.message(TopupStates.waiting_amount)
async def topup_amount_input(message: Message, state: FSMContext):
    try:
        amount = float(message.text)
        if amount < 100:
            raise ValueError
    except:
        await message.answer("Ошибка: сумма ≥ 100 ₽")
        return

    code = generate_code()
    user_id = message.from_user.id

    async with aiosqlite.connect(DB_NAME) as db:
        await db.execute("INSERT INTO topups (user_id, amount, code, status) VALUES (?, ?, ?, ?)",
                         (user_id, amount, code, 'pending'))
        await db.commit()

    await message.answer(
        f"**Пополнение на {amount} ₽**\n\n"
        f"Переведите **ровно {amount} ₽** на:\n"
        f"**{TOPUP_PHONE}**\n"
        f"Получатель: **{TOPUP_NAME}**\n"
        f"Банк: **{TOPUP_BANK}**\n\n"
        f"**В комментарии укажите код:**\n"
        f"`{code}`\n\n"
        f"После перевода — ожидайте подтверждения.",
        parse_mode="Markdown"
    )

    await bot.send_message(
        ADMIN_ID,
        f"Пополнение от @{message.from_user.username or user_id}\n"
        f"Сумма: {amount} ₽\n"
        f"Код: `{code}`\n\n"
        f"/approve_topup_{user_id}_{amount}\n"
        f"/reject_topup_{user_id}",
        parse_mode="Markdown"
    )
    await state.clear()

# === ВЫВОД ===
@router.message(Command("withdraw"))
async def withdraw_start(message: Message, state: FSMContext):
    if await get_role(message.from_user.id) != "executor":
        await message.answer("Только для исполнителей!")
        return
    bal = await get_balance(message.from_user.id)
    if bal < MIN_WITHDRAW:
        await message.answer(f"Минимум {MIN_WITHDRAW} ₽")
        return
    await message.answer("Кошелёк:")
    await state.set_state(WithdrawStates.waiting_wallet)

@router.message(WithdrawStates.waiting_wallet)
async def withdraw_wallet_input(message: Message, state: FSMContext):
    await state.update_data(wallet=message.text.strip())
    await message.answer("Сумма:")
    await state.set_state(WithdrawStates.waiting_amount)

@router.message(WithdrawStates.waiting_amount)
async def withdraw_amount_input(message: Message, state: FSMContext):
    try:
        amount = float(message.text)
    except:
        await message.answer("Только число")
        return
    bal = await get_balance(message.from_user.id)
    if amount > bal or amount < MIN_WITHDRAW:
        await message.answer(f"От {MIN_WITHDRAW} до {bal:.2f}")
        return

    data = await state.get_data()
    user_id = message.from_user.id

    async with aiosqlite.connect(DB_NAME) as db:
        await db.execute("UPDATE users SET balance = balance - ? WHERE user_id = ?", (amount, user_id))
        await db.execute("INSERT INTO withdrawals (user_id, amount, wallet, status) VALUES (?, ?, ?, ?)",
                         (user_id, amount, data['wallet'], 'pending'))
        await db.commit()

    await message.answer(f"Заявка на вывод {amount} ₽ → {data['wallet']}")
    await bot.send_message(
        ADMIN_ID,
        f"Вывод от @{message.from_user.username or user_id}\n"
        f"Сумма: {amount} ₽\n"
        f"Кошелёк: {data['wallet']}\n\n"
        f"/approve_withdraw_{user_id}_{amount}\n"
        f"/reject_withdraw_{user_id}"
    )
    await state.clear()

# === АДМИН ===
@router.message(Command(commands=["approve_topup_", "reject_topup_", "approve_withdraw_", "reject_withdraw_"]))
async def admin_action(message: Message):
    if message.from_user.id != ADMIN_ID:
        return
    parts = message.text.split("_")
    action = parts[0][1:]
    user_id = int(parts[2])
    amount = float(parts[3]) if len(parts) > 3 else 0

    async with aiosqlite.connect(DB_NAME) as db:
        if action == "approve_topup":
            await add_balance(user_id, amount)
            await db.execute("UPDATE topups SET status = 'approved' WHERE user_id = ? AND amount = ?", (user_id, amount))
            await bot.send_message(user_id, f"Пополнение {amount} ₽ подтверждено!")
        elif action == "reject_topup":
            await db.execute("UPDATE topups SET status = 'rejected' WHERE user_id = ?", (user_id,))
            await bot.send_message(user_id, "Пополнение отклонено.")
        elif action == "approve_withdraw":
            await db.execute("UPDATE withdrawals SET status = 'approved' WHERE user_id = ? AND amount = ?", (user_id, amount))
            await bot.send_message(user_id, f"Вывод {amount} ₽ одобрен!")
        elif action == "reject_withdraw":
            await add_balance(user_id, amount)
            await db.execute("UPDATE withdrawals SET status = 'rejected' WHERE user_id = ?", (user_id,))
            await bot.send_message(user_id, "Вывод отклонён. Деньги возвращены.")
        await db.commit()
    await message.delete()

# === ЗАПУСК ===
async def main():
    await init_db()
    print("ReviewCash Bot запущен! Чат ЧИСТЫЙ!")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
